'''

ToDo
    - Estimate number of bits in each set of words

Script to generate easier-to-remember passwords than modern "recommendations"

'''
if 1:   # Header
    if 1:   # Copyright, license
        # These "trigger strings" can be managed with trigger.py
        #∞copyright∞# Copyright (C) 2023 Don Peterson #∞copyright∞#
        #∞contact∞# gmail.com@someonesdad1 #∞contact∞#
        #∞license∞#
        #   Licensed under the Open Software License version 3.0.
        #   See http://opensource.org/licenses/OSL-3.0.
        #∞license∞#
        #∞what∞#
        # Questions to help generate a password
        #∞what∞#
        #∞test∞# #∞test∞#
        pass
    if 1:   # Standard imports
        from pathlib import Path as P
        import getopt
        import math
        import os
        import random
        import secrets
        import sys
    if 1:   # Custom imports
        from f import flt
        from wrap import dedent
        from color import t 
        from timer import AdjustTimeUnits
        try:
            import mpmath
            have_mpmath = True
        except ImportError:
            have_mpmath = True
    if 1:   # Global variables
        class G:
            pass
        g = G()     # Global variables as attributes to this instance
        g.words = (
            P("/words/words.ef.3000"),
            P("/words/words.beale.2of12inf"),
            P("/words/words.ngsl.experimental"),
            P("/words/words.univ"),
        )
        g.wordlist = None
        ii = isinstance
if 1:   # Utility
    def Error(*msg, status=1):
        print(*msg, file=sys.stderr)
        exit(status)
    def Manpage():
        print(dedent(f'''

        - Also see random_phrase.py and perm.py in /plib/pgm
        - The estimate of the number of bits in a password is a bit conservative (see the comments
          for the function GetBits()).
        - The number of symbols in the wordlists vary:  -0:47, -1:26, -2:29, -3:63
        - The default wordlist is -0 and I recommend this for passwords that more easily
          remembered.  The remaining wordlists contain more complex words.  The -3 option will
          probably have many unfamiliar words.
        - I recommend using a password manager application to store your passwords.  Then you only
          have to memorize one good password.
        - For important stuff (e.g. banking, retirement account, etc.) use high-strength passwords
          generated by your password generator and, preferably, two factor authorization.
        - For passwords that you need to remember for things you can't easily keep on your
          computer, the sets of words generated by this script might be useful.  I wouldn't
          hesitate to permute the words to make the thing easier to remember (see
          /plib/pgm/perm.py).
        - You can make up a memorable word phrase or use an advertising slogan.  For example, in
          the 1970's a Yuban coffee TV commercial used the phrase "Jim never has a second cup of
          coffee" (it was used in the movie 'Airplane').  This would abbeviate to 'jnhascoc'.  This
          is not long enough for today's passwords (16 characters is commonly recommended as a
          minimum), so use another one like GE's "we bring good things to life" to get
          'jnhascocwbgttl'.  Still not enough, but you get the idea.
        - The cartoon https://xkcd.com/936/ pokes fun at humans' attempt to make secure passwords.
        - For me, the easiest passwords to remember are ones made up from some memorable event.
          For example, we had a pet duck named Daddles and Daddles quickly learned to recognize me
          carrying a shovel across our yard, as it meant that I would be digging a hole.  This
          human-bonded duck would wait for me to dig, then climb down into the hole to get worms.
          When the grandkids were little they thought it was hilarious to cover up Daddles' eyes,
          then have me go across the yard with a shovel.  When they uncovered Daddles' eyes, she
          would run as fast as she could towards me, as ducks have very good eyesight.  So a good
          password for me to remember would be 'DaddlesLovesShovels96', where 96 is the last two
          digits of the year one of the grandkids was born.  My password manager says this has 96
          bits, a fairly strong password.

        '''.rstrip()))
        SecurityEstimates()
        exit()
    def Usage():
        print(dedent(f'''
        Usage:  {sys.argv[0]} [options] numwords [numlines [maxchars [minchars]]]
          Print line(s) containing numwords of words randomly selected from a wordlist.  Optional
          arguments:
            numlines = number of lines to print [1]
            maxchars = maximum number of characters allowed in words [any]
            minchars = minimum number of characters allowed in words [1]
          If you want to constrain only the minimum number of characters, set maxchars to '-' and
          set minchars appropriately.  The output is random and not repeatable unless you use the
          -s option.  A conservative estimate of the number of bits in the password is printed in
          square brackets and clamped to be less than 10000.
        Options:
            -0      Simple wordlist (3000 words) [default]
            -1      Moderately-sized wordlist (16378 words)
            -2      Large list of words from Alan Beale (81882 words)
            -3      Complex wordlist (302618 words)
            -H      Discuss security
            -h      Print a manpage
            -s st   Define seed string st to use repeatable pseudorandom generator
        '''))
        exit(0)
    def ParseCommandLine(d):
        d["-s"] = None      # Random number seed; implies pseudorandom number generator
        if len(sys.argv) < 2:
            Usage()
        try:
            opts, args = getopt.getopt(sys.argv[1:], "0123Hhs:") 
        except getopt.GetoptError as e:
            print(str(e))
            exit(1)
        for o, a in opts:
            if o[1] in list(""):
                d[o] = not d[o]
            elif o[1] in list("0123"):
                g.wordlist = int(o[1])
            elif o == "-H":
                SecurityEstimates()
            elif o == "-h":
                Manpage()
            elif o in ("-s",):
                d["-s"] = a
        if g.wordlist is None:
            g.wordlist = 0
        return args
if 1:   # Core functionality
    def SecurityEstimates():
        '''Print out a table of estimated time to crack a password as a function of number of bits
        and the number of operations per second that can be done.  This is a back of the envelope
        calculation, not one rooted in current practices.  See
        https://www.hivesystems.com/blog/are-your-passwords-in-the-green for a discussion of this
        topic.
 
        Here, operations per second is in Hz.  The above URL gives us some order of magnitude
        estimates appropriate for around the year 2024.
 
        https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma#Security_properties states the
        number of permutations of letters in the World War 2 enigma machine was 1.5e14, which is
        47 bits.
        '''
        def T(s):   # Short time units
            di = {"seconds": "s", "minutes": "m", "hours": "h", "days": "d", "weeks": "w",
                "months": "M", "years": "y"}
            for i in di:
                if s.endswith(i):
                    return s.replace(i, di[i])
            raise ValueError(f"{s!r} not handled")
        freq = (1e6, 200e9, 2e12, 2e15)
        w1, w2, sep = 5, 8, " "*4
        desc = (
            "Script kiddie with one computer",
            "Hacker with home computer with state of the art graphics card",
            "Rental cloud service",
            "Government resources",
        )
        print(dedent(f'''

        The following table estimates the time to crack a password by brute force searching.  The
        time is 2**bits/f where f is operation frequency in Hz.  Here, an operation is e.g. a
        password checking or hash computation.  Example:  for 35 bits, 2**bits is 3.4e10
        operations.  For 1 MHz operation frequency, the time is 3.4e10/(1e6 Hz) or 34000 seconds.
        This is about 10*3600 seconds or 10 hours.  This is the time it takes to check all possible
        permutations of the assumed symbol set.
        
        On my 10 year old 4 core 3.5 GHz computer running python 3.11.5, the itertools.permutations
        library tool generated permutations at about 15 MHz (tested for 10, 11, and 12 characters).

        The columns in the table are:
        '''.rstrip()))
        for f, descr in zip(freq, desc):
            x = flt(f)
            print(f"    {x.engsi + 'Hz':<{w2}s}     {descr}")
        print()
        print(dedent(f'''
        The time units s, m, h, d, w, M, y are seconds, minutes, hours, days, weeks, months, and
        years.

        An assumption needed to assess a "good" number of bits is how long the person
        trying to find the password is willing to wait.  If an item in the table is blank, it's
        either less than 1 second or greater than 100 years.  I assumed that few people or
        organizations would be willing to wait 100 years for an answer.

        '''.rstrip()))
        print()
        numbits = range(15, 101, 5)
        print(f"{'Bits':>{w1}s}", end=sep)
        for f in freq:
            x = flt(f)
            print(f"{x.engsi + 'Hz':>{w2}s}", end=sep)
        print()
        for bits in numbits:
            print(f"{bits:>{w1}d}", end=sep)
            for Hz in freq:
                sec = 2**bits/Hz
                if sec < 1:
                    s = ""
                else:
                    # 3.1556926e+09 s is 100 years
                    if sec > 3.1556926e+9:
                        s = ""
                    else:
                        s = T(AdjustTimeUnits(sec, digits=1))
                print(f"{s:>{w2}s}", end=sep)
            print()
        print()
        print(dedent(f'''
        Another aspect of the problem is who is being hacked.  For a person's data, cracking might
        be used or if it was more urgent, break into his home and get his computer's disk drives'
        contents.  For nuclear sub missle launch codes, they hopefully are guarded by security
        measures many of orders of magnitude more complex and difficult.

        '''.rstrip()))

if 1:
    SecurityEstimates() #xx
    exit()

    def CheckParameters(numwords, numlines, maxchars, minchars):
        if numwords < 1:
            Error("numwords must be an integer > 0")
        if numlines < 1:
            Error("numlines must be an integer > 0")
        if minchars < 1:
            Error("minchars must be an integer > 0")
        if maxchars < minchars:
            Error("maxchars must be an integer > 0 and be larger than minchars")
    def GetBits(passwd: list, numsymbols: str):
        '''Estimate the number of bits in the list of words.  This will be int(log2(N**P)) where 
            N = number of possible symbols (numsymbols)
            P =  number of characters in ''.join(passwd)
        One can quibble about this calculation, as I've used the set of the actual characters in
        the password, not the population set that the actual set was drawn from.  I consider this
        reasonable, as the randomly selected items are from a word list, not randomly drawn from a
        large set of characters.
 
        The basic purpose of this script is to produce passwords using groups of English words with
        the intent that such a password is probably easier for the average human to remember than
        something like 'QlN<^y;_[1416D]$NwSx?CKGou5v)vC}', produced by my password management
        software and labeled as having 191 bits, a very strong password.  
 
        I'd use the output of this script for things like a password for my NAS box or a wifi
        password at home.  I'd _never_ use this output for something like a bank or financial
        account.  In fact, for such things I insist on very strong passwords AND two factor
        authorization.
        '''
        N = len(set(''.join(passwd)))   # Number of unique symbols used in list of words
        P = len(''.join(passwd))        # Number of symbols in list of words
        # This is the Shannon entropy formula, but it will be lower than an estimate that uses all
        # the possible symbols, such as the 7-bit ASCII characters from ' ' to '~!'.
        if have_mpmath:
            mpf = mpmath.mpf
            n = mpf(N)**mpf(P)
            bits = int(mpmath.ln(n)/mpmath.ln(2))
        else:
            n = flt(N**P)
            bits = int(round(math.log2(n), 0))
        if bits > 9999:
            bits = 9999
        elif bits < 1:
            bits = 1
        return bits
    def Calculate(numwords, numlines, maxchars, minchars):
        '''Print the indicated numbers of words
        numwords = number of words per line
        numlines = number of lines to print
        maxchars = maximum number of characters per word
        minchars = minimum number of characters per word
        '''
        # Get the word list
        file = g.words[g.wordlist]
        assert file.exists()
        with open(file) as f:
            words = [word.strip() for word in f]
            # Only keep words with lengths between minchars and maxchars
            words = [i for i in words if minchars <= len(i) <= maxchars]
        numsymbols = len(set(''.join(words)))   # Does not include the space character
        if d["-s"] is None:
            # Random selection, cannot be repeated
            for i in range(numlines):
                passwd = [secrets.choice(words) for i in range(numwords)]
                bits = GetBits(passwd, numsymbols)
                print(f"{t('lill')}[{bits:4d}]{t.n} {' '.join(passwd)}")
        else:
            # Pseudorandom number generator, same output for same seed
            random.seed(d["-s"])
            for linenum in range(numlines):
                passwd = []
                for i in range(numwords):
                    k = random.randint(0, len(words) - 1)
                    passwd.append(words[k])
                bits = GetBits(passwd, numsymbols)
                print(f"{t('lill')}[{bits:4d}]{t.n} {' '.join(passwd)}")

if __name__ == "__main__":
    d = {}      # Options dictionary
    maxchars = 1000  # Much large number of characters than any word in wordlists
    args = ParseCommandLine(d)
    numwords = int(args[0])
    numlines = int(args[1]) if len(args) > 1 else 1
    if len(args) > 2 and args[2] != "-":
        maxchars = int(args[2])
    minchars = int(args[3]) if len(args) > 3 else 1
    CheckParameters(numwords, numlines, maxchars, minchars)
    Calculate(numwords, numlines, maxchars, minchars)
