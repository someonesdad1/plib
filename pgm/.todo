* Two of the most common keypresses are ctrl-C and ctrl-V.  These should be
  assigned to a single easy to access keypress.

* A fundamental problem when coding is that a data structure is developed
  and you start using it in your code.  Then you always have to stop and
  look around the code to figure out the structures again.  Is there a way
  to add a utility that documents the structures so e.g. a command line
  option will print out a succinct summary by the code examining itself?
  Ideally, this would be just a few lines of code that are easy to remove
  when done (or, better, leave it in for later maintenance).

* Since flt is essentially done, write a replacement for fpformat.py that 
  includes its features.

* dpmath.py:  This would be a general-purpose module for math calculations.
    * Types
        * flt:  derived from float
        * dec:  derived from Decimal
        * cpx:  derived from complex
        * dpx:  two Decimal instances giving a complex number
    * Math
        * All math/cmath functions in scope
        * Work for all types
        * Special function support if mpmath is available
    * Try to put essential details in a Base class
    * Key features
        * String interpolation only shows a given number of significant
          figures
        * The instances are context managers, allowing code like

            with x:
                x.n += 3
                print(x)

          to let you change the number of digits as needed.  Or, define a
          __call__(self, n=None) to do this without needing a lock.
        
        * Infection model
            * Need a strict attribute in Base.  If True, interoperation
              with Fractions or floats for dec or dpx is not allowed
              because of the chance of losing information or adding noise.
        * Units:  It would be great to make these a mixin, but this is
          going to be hard.
        * REPL:  if this can be gotten to work, then the repl I wrote will
          be a nice command line tool suitable for routine calculations.
    * Need to coalesce f.py, dpdecimal.py, and decimalmath.py.

* pgm/ds.py
    * Store every command and provide a -l option to show the history.
      This would be useful for remembering previous commands.

* what.py
    * Should be able to examine a file and list the dependencies on
      scripts.  Look at pgm/dep.py and the modulefinder module.  Then
      what.py should only print out the non-standard modules.

* Move $PP/uni.py to /plib/pgm.  Remove the lookup of the PDF stuff.

* pgm/char.py
    * When a line (e.g. Lower) is complete with all the allowed characters,
      print <all> at the end to denote this state.  Also add -s option,
      which removes the space between characters, giving a more compact
      output.  For -c option, include summary stats.

* /plib/density.py
    * For common density values.  This file would then be read by
      /plib/pgm/density.py for its data.  Having things in a module mean
      other apps can use it.
    * One addition would be to provide canonical values for common
      materials like steel, brass, iron, elements, etc.

* dpstr.py
    * Tokenize(s):  split a string into a sequence S such that ''.join(S)
      == s.  The keyword wordchars is a set that contains the characters
      that should NOT be split on.  wordchars would default to
      string.ascii_letters.  A better default would be "un latin |grep -i
      letter" and limited to letters < 0x17f (this is 237 letters).

      This means a sentence like "Must be:  exp, log." needs to be
      parsed as

      ['Must', ' ', 'be', ':', '  ', 'exp', ',', 'log', '.']
 
      such that ''.join(x) reproduces the original string.  This function
      should be in dpstr.py.  Numbers in names could be an issue.

      First check if char is in string.ascii_letters because this will be
      fast.  Then check for the following set:

        žŽżŻźŹŸŷŶŵŴųŲűŰůŮŭŬūŪũŨŧŦťŤţŢšŠşŞŝŜśŚřŘŗŖŕŔőŐŏŎōŌŋŊŉňŇņŅńŃłŁŀĿľĽļĻĺĹ
        ĸķĶĵĴıİįĮĭĬīĪĩĨħĦĥĤģĢġĠğĞĝĜěĚęĘėĖĕĔēĒđĐďĎčČċĊĉĈćĆąĄăĂāĀÿþýüûúùøöõôóò
        ñðïîíìëêéèçæåäãâáàßÞÝÜÛÚÙØÖÕÔÓÒÑÐÏÎÍÌËÊÉÈÇÆÅÄÃÂÁÀ

    * Add a TokenSplit(token, seq) function that will split a token into a
      list of subtokens.  If seq is a string, then it will be split on 
      any of the characters in the string.  Otherwise, str.split() will
      have to be called with each sequence item.

* wrap.py:  
    * Look at syntax from ts.py (/pylib/pgm/ts/ts.py).  I seem to have
      designed it as a module, so it might be the tool of choice.
    * This really needs to be a simple text formatting language.  In
      particular, it could be simply a Wrap object with a __call__ method
      that gives you the functionality desired with keyword arguments.
        * A dedent keyword would remove common whitespace from lines if
          True; otherwise, it would be an int that tells how many spaces to
          remove from each line.
        * The common use case would be for Usage/manpage stuff in python
          scripts, so tune syntax to this case.
        * f-strings are used most frequently, but also need to handle case
          with older '{}'.format(**locals()) type stuff.
        * Need simple syntax for common tasks.  Maybe leading '.' is all
          that's needed within a text string. '.^' to center, '.>' to
          right-justify, '.' to leave untouched, etc.  
    * Add a Block object that is like wrap, but justifies both the right
      and left margins.
    * Add a fold function that folds a string into a width, breaking where
      necessary.
    * For wrap(), it would be nice to have a simple syntax for lines that
      should be left verbatim.  Maybe a leading '.' would do it.  This lets
      you e.g. have header lines in a manpage like 
        .This is a section title
        .-----------------------
      and they get left alone.
    * print(dedent(f'''
      This
      ''')) chops off the 'T'.

* f.py
    * /plib/pgm/divider.py is a good example of poorer performance of the
      f.py module.  With sig.py, it took 0.4 s.  Using flt objects instead
      the overall time for a script increased to 4.4 s.  I changed it back
      to use sig.py.
    * Should color.c() be used in f.py?
    * Sometimes you want to perform calculations regardless of units.  This
      case could be handled with a property called iu that means ignore the
      units.  Then the self.val float would be used in calculations.  You'd
      only want to use this in a with block.
    * Allow init from "3in" or "3 in".
    * Must allow some functions to have arguments with units.  Example:
      take the square root of an area.  Each of the functions' behaviors
      need to be thought out for both real and complex arguments.  The Dim
      class may then need to specifically allow rational exponents.
        * math
            * Must be dimensionless:  acos, acosh, asin, asinh, atan,
              atanh, exp, expm1, log, log1p, log2, log10, degrees, radians,
              erf, erfc, gamma, lgamma
            * Could handle units, but return value disallows:  ceil, floor,
              gcd, trunc
            * Probably OK with units:  atan2, copysign, fabs, fmod (args
              must have same units), frexp, fsum, isclose, isfinite, isinf,
              isnan, modf, remainder, pow (first argument), sqrt, hypot
        * cmath
            * Must be dimensionless:  exp, log, log10, acos, asin, atan,
              cos, sin, tan, acosh, asinh, atanh, cosh, sinh, tanh
            * Probably OK with units:  phase, polar, rect, sqrt, isfinite,
              isinf, isnan, isclose
        * The general test should be that the function's answer should be
          "obvious".  Thus, for exp(), I wouldn't be able to decide whether
          the value used should be the SI value or the .val attribute,
          meaning exp() cannot take a flt/cpx with units.  However, atan2
          is OK if the two arguments are dimensionally consistent because
          it's their ratio that is used in the function.  Thus, the
          function is allowed with units if you get the same answer using
          either "interpretation" of the number.  For some functions like
          isclose, you need the two arguments to be dimensionally
          consistent and use the same interpretation.
    * Test_sigcomp() fails.
    * flt:  add the engsi feature that will print a prefix with a unit.  If
      it's a multiple unit, surround it in (...).
    * f.py:  see line 150 in test/lwtest_test.py.  
    
        b = cpx(1+1j)
        b.promote = 0
        a = cpx(1+1j, units="m")
        Then in debugger, both a==b and a!=b are False

----------------------------------------------------------------------
Mac stuff

    Will be $2k 14" Macbook Pro with 16 GB RAM and 0.5 TB SSD
        https://www.apple.com/shop/buy-mac/macbook-pro/14-inch

    Good overview of getting started:
        https://mackeeper.com/blog/learn-how-to-use-mac/

    Display
        * My Windows box runs at 3840x2160 resolution.  The monitor is a
          24 inch Dell F2415Q monitor.  Wayne uses a 27 inch monitor.

    Setup
        * https://www.howtogeek.com/449715/how-to-set-up-your-new-mac/
        * Note both Firefox and Chrome are available for the Mac.  It may
          make sense to install both.
        * Spotlight sounds useful, but has privacy concerns.  Read
          https://en.wikipedia.org/wiki/Spotlight_(software) at bottom of
          page to see how to disable the built-in sharing.
        * https://theunarchiver.com/ for archive support better than the
          default
        * https://freemacsoft.net/appcleaner/ to clean up after the apps
          you want deleted
        * https://transmissionbt.com/ as a free and good BitTorrent client
        * https://www.howtogeek.com/671085/how-to-switch-between-open-apps-and-windows-on-mac/
          to switch between apps like alt-tab in Windows
        * https://www.techrepublic.com/article/how-to-create-a-virtual-desktop-in-macos/
          to create virtual desktops
        * https://www.howtogeek.com/720194/how-to-turn-on-tap-to-click-on-mac/
        * vim 
            * https://sourabhbajaj.com/mac-setup/Vim/README.html
            * https://www.javatpoint.com/how-to-install-vim-on-mac
        * go2shell https://apps.apple.com/us/app/go2shell/id445770608?mt=12
          Put this into the finder toolbar, press the button and you have a
          shell window open for that directory.
        * xcode is the default IDE/environment for Apple device programming
          and requires a minimum of 8 GB of RAM and can take an hour or two
          to download.  It can be installed from a terminal with 'sudo
          xcode-select --install'.
        * Various software suggestions are made at
          https://codeforgeek.com/setting-up-mac-for-development-coding/
          for a coding environment, but the website is horrible because you
          can't copy text.
        * Should take a look at zsh:
          https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/

    Multiple monitors
        * https://www.howtogeek.com/443460/how-to-use-multiple-monitors-on-your-mac/
        * A core question is what monitor I should use.  Since the
          interface from an adapter will have two HDMI connections, should
          I assume that any monitor with HDMI should work?
        * https://plugable.com/blogs/news/best-hub-and-docking-station-for-the-apple-m1-pro-macbook-pro-laptop
          https://plugable.com/blogs/news/tagged/thunderbolt%E2%84%A2-4

    Keyboard shortcuts
        * https://support.apple.com/en-us/HT201236
        * Specific app shortcuts:  https://support.apple.com/guide/mac-help/create-keyboard-shortcuts-for-apps-mchlp2271/mac
        * Use the Windows key for Cmd if you're using a PC keyboard and alt
          for the opt key.
        * Spotlight cmd-space
            * Press and hold cmd-space for Siri
        * Set up for the most commonly-used tasks.  One keypress to copy to
          clipboard, one keypress to paste, one keypress to paste and press
          the Enter key.

    Note the Macbook Pro has no touchbar.
    https://screenrant.com/apple-2021-macbook-pro-no-touch-bar-why/
    I liked the idea for the customizability, but the glaring weakness is
    that it won't be available in a docked laptop because I'll probably use
    a PC keyboard.  Then I'll want the function keys.

----------------------------------------------------------------------
WaveXpress

    Get WaveXpress to run in python 3.  It's available at
    https://www.bkprecision.com/wavexpress.html.

    Core question

        Should it be written in python or C++?  If in C++, I'm gonna be
        rusty, but there could be some speed and memory benefits and python
        could be built in as a scripting language.  A nice feature of using
        C++ is that the source code won't be available.

    Desktops:  Windows 95%, Mac 4%, Linux 1%

    I'll split the development into two key phases:

        Phase 1:  Construct the basic GUI for the program with numpy
        support and the ability to plot and manipulate graphs.  The new
        design should include the time axis.  The old features should
        be available along with:

            * More than one function can be plotted in one window.
            * Two basic types of data:
                * No timebase
                * Timebase
            * Data types from files:
                * No time data:  one or more vectors
                * Time data:  one or more vectors
                * An interactive spreadsheet type display lets you define
                  the vectors, time, and define measurement units.
            * Convert no time data to timebase data by picking two points
              and defining the time between them
            * Vectors can be integer or floating point

            * Major questions
                * What is new architecture to support time & no time?
                * If wxPython, how will new GUI dialogs be designed?  See
                  https://www.tutorialspoint.com/wxpython/wxpython_gui_builder_tools.htm
                  wxFormBuilder, wxDesigner, wxGlade, BoaConstructor,
                  gui2py.  See https://en.wikipedia.org/wiki/WxFormBuilder
                  for details on one; note it can generate python code.
                  https://github.com/wxFormBuilder/wxFormBuilder says it
                  can be installed on Mac and it looks easy.  **** OK, this
                  looks like it might not be an issue anymore.  ***

        Phase 2:  Add support for instruments.  This is a major part, as it
        requires serial connections, USB, and GPIB.  It also requires a
        large NI download for GPIB support.  It would be nice to find a way
        to talk to USB or serial devices only withing this crushing NI
        library need.  

    If phase 1 completes successfully, then I'll contact B&K and see if
    they would be interested in paying for a new version.  If they are,
    then I'd need help with an overall product design plan.  My guess is
    they'd only be interested in supporting Windows platforms.

----------------------------------------------------------------------
Sprinklers

    The ESP32 chip with the RS485 boards (under $10 for each) would be a
    nice way to construct a sprinkler controller.  The ESP32 would be a
    stand-alone controller, but would allow serial communication with
    another ESP32 chip in the house in my office; the connection could be
    made over wifi.  This would allow modifying the stored program of the
    controller, interrupting things, etc.  In fact, a simple approach would
    be to provide a command line interface for controlling the remote chip
    and to get status.

    Unfortunately, it appears this chip can only be accessed from Windows,
    as you need to download a driver for it.

    I'd like to see the stand-alone processor have a switch that selects
    automatic mode or manual mode.  In manual mode, there's a pushbutton
    switch for each sprinkler to turn on, along with the pump.

    Since these chips also support bluetooth, there should be an app to
    control their settings via bluetooth also.  This means you could do
    sprinkler control from your phone.

    Maybe the only interface needed would be a serial connection in one of
    the rooms.  Then you connect a computer to it for control and settings.
    All that's needed is a 9600 baud connection for text messages.

----------------------------------------------------------------------
Low priority

* fold.py
    * This will change text files to have one space on blank lines or no
      spaces on blank lines.  Need to intelligently process python files?
      The default behavior would be to print each line with 2 lines of
      context on either side.  Then if you like what you see, use -x to
      make the changes.  The intent is to get a source file where { and }
      can be used to navigate to sections you're working on.  Python files
      will be some work because you need to leave multiline strings intact.

* british.py
    * Move to plib and give it a function that will take a sentence of text
      and replace all the British words with English words, maintaining
      capitalization and punctuation.  This will require another function
      to split a string into a list of words and punctuation characters.
      It would be nice to also maintain the spaces between the words too.
      See the next function, which should be in dpstr.py.

* geom_prim.py
    * Update properties to modern syntax, utilize matrix.py for
      determinants, as this would remove dependency on numpy.

* u.py and f.py
    * A notation for using SI prefixes could be to use something like
      μ(N*s/m^2).  This might not be acceptable SI syntax, but it would be
      understandable by anyone and I should use it if the tokenizer in the
      u.py script can be made to utilize it.  A way to do this might be to
      simply insert the equivalent number with a multiplication sign on the
      right when it's encountered; this should evaluate OK with python's
      parser.

* module_dependencies.py
    * Is it necessary?  It needs to be rewritten to accommodate /plib.  The
      tools and programs need to be moved in first.  

* sig.py
    * Is a mess of code.  Is it really all needed?  Maybe it would be best
      to move the key stuff to flt and cpx.  It can still be kept around
      for when it's needed.

* ts.py
    * 'ts.py -m' doesn't work.

* /pylib/pgm/readability/indict.py
    * Looks like