* Resistor design:  I'm often wondering about a shunt resistor for current
  control.  Given a resistance value, print out the operating points for
  1/4, 1/2, 1, 5, 10, 25, and 50 W power dissipations.

* notes file:  write a python replacement for agrep.  First, see if the
  cygwin setup tool offers it.

* dpmath.py:  This would be a general-purpose module for math calculations.
    * Types
        * flt:  derived from float
        * dec:  derived from Decimal
        * cpx:  derived from complex
        * dpx:  two Decimal instances giving a complex number
    * Math
        * All math/cmath functions in scope
        * Work for all types
        * Special function support if mpmath is available
    * Try to put essential details in a Base class
    * Key features
        * String interpolation only shows a given number of significant
          figures
        * The instances are context managers, allowing code like

            with x:
                x.n += 3
                print(x)

          to let you change the number of digits as needed.  Or, define a
          __call__(self, n=None) to do this without needing a lock.
        
        * Infection model
            * Need a strict attribute in Base.  If True, interoperation
              with Fractions or floats for dec or dpx is not allowed
              because of the chance of losing information or adding noise.
        * Units:  It would be great to make these a mixin, but this is
          going to be hard.
        * REPL:  if this can be gotten to work, then the repl I wrote will
          be a nice command line tool suitable for routine calculations.
    * Need to coalesce f.py, dpdecimal.py, and decimalmath.py.

* pgm/ds.py
    * Store every command and provide a -l option to show the history.
      This would be useful for remembering previous commands.

* what.py
    * Should be able to examine a file and list the dependencies on
      scripts.  Look at pgm/dep.py and the modulefinder module.  Then
      what.py should only print out the non-standard modules.

* pgm/char.py
    * When a line (e.g. Lower) is complete with all the allowed characters,
      print <all> at the end to denote this state.  Also add -s option,
      which removes the space between characters, giving a more compact
      output.  For -c option, include summary stats.

* /plib/density.py
    * For common density values.  This file would then be read by
      /plib/pgm/density.py for its data.  Having things in a module mean
      other apps can use it.
    * One addition would be to provide canonical values for common
      materials like steel, brass, iron, elements, etc.

* dpstr.py
    * Tokenize(s):  split a string into a sequence S such that ''.join(S)
      == s.  The keyword wordchars is a set that contains the characters
      that should NOT be split on.  wordchars would default to
      string.ascii_letters.  A better default would be "un latin |grep -i
      letter" and limited to letters < 0x17f (this is 237 letters).

      This means a sentence like "Must be one of:  exp, log." needs to be
      parsed as

        x = ["Must", " ", "be", " ", "one", "of", ":", "  ", "exp", "."]
 
      such that ''.join(x) reproduces the original string.  This function
      should be in dpstr.py.  Numbers in names could be an issue.

      First check if char is in string.ascii_letters because this will be
      fast.  Then check for the following set:

        žŽżŻźŹŸŷŶŵŴųŲűŰůŮŭŬūŪũŨŧŦťŤţŢšŠşŞŝŜśŚřŘŗŖŕŔőŐŏŎōŌŋŊŉňŇņŅńŃłŁŀĿľĽļĻĺĹ
        ĸķĶĵĴıİįĮĭĬīĪĩĨħĦĥĤģĢġĠğĞĝĜěĚęĘėĖĕĔēĒđĐďĎčČċĊĉĈćĆąĄăĂāĀÿþýüûúùøöõôóò
        ñðïîíìëêéèçæåäãâáàßÞÝÜÛÚÙØÖÕÔÓÒÑÐÏÎÍÌËÊÉÈÇÆÅÄÃÂÁÀ

    * Add a TokenSplit(token, seq) function that will split a token into a
      list of subtokens.  If seq is a string, then it will be split on 
      any of the characters in the string.  Otherwise, str.split() will
      have to be called with each sequence item.

* wrap.py:  
    * Look at syntax from ts.py (/pylib/pgm/ts/ts.py).  I seem to have
      designed it as a module, so it might be the tool of choice.
    * This really needs to be a simple text formatting language.  In
      particular, it could be simply a Wrap object with a __call__ method
      that gives you the functionality desired with keyword arguments.
        * A dedent keyword would remove common whitespace from lines if
          True; otherwise, it would be an int that tells how many spaces to
          remove from each line.
        * The common use case would be for Usage/manpage stuff in python
          scripts, so tune syntax to this case.
        * f-strings are used most frequently, but also need to handle case
          with older '{}'.format(**locals()) type stuff.
        * Need simple syntax for common tasks.  Maybe leading '.' is all
          that's needed within a text string. '.^' to center, '.>' to
          right-justify, '.' to leave untouched, etc.  
    * Add a Block object that is like wrap, but justifies both the right
      and left margins.
    * Add a fold function that folds a string into a width, breaking where
      necessary.
    * For wrap(), it would be nice to have a simple syntax for lines that
      should be left verbatim.  Maybe a leading '.' would do it.  This lets
      you e.g. have header lines in a manpage like 
        .This is a section title
        .-----------------------
      and they get left alone.
    * print(dedent(f'''
      This
      ''')) chops off the 'T'.

* f.py
    * /plib/pgm/divider.py is a good example of poorer performance of the
      f.py module.  With sig.py, it took 0.4 s.  Using flt objects instead
      the overall time for a script increased to 4.4 s.  I changed it back
      to use sig.py.
    * Should color.c() be used in f.py?
    * Sometimes you want to perform calculations regardless of units.  This
      case could be handled with a property called iu that means ignore the
      units.  Then the self.val float would be used in calculations.  You'd
      only want to use this in a with block.
    * Allow init from "3in" or "3 in".
    * Must allow some functions to have arguments with units.  Example:
      take the square root of an area.  Each of the functions' behaviors
      need to be thought out for both real and complex arguments.  The Dim
      class may then need to specifically allow rational exponents.
        * math
            * Must be dimensionless:  acos, acosh, asin, asinh, atan,
              atanh, exp, expm1, log, log1p, log2, log10, degrees, radians,
              erf, erfc, gamma, lgamma
            * Could handle units, but return value disallows:  ceil, floor,
              gcd, trunc
            * Probably OK with units:  atan2, copysign, fabs, fmod (args
              must have same units), frexp, fsum, isclose, isfinite, isinf,
              isnan, modf, remainder, pow (first argument), sqrt, hypot
        * cmath
            * Must be dimensionless:  exp, log, log10, acos, asin, atan,
              cos, sin, tan, acosh, asinh, atanh, cosh, sinh, tanh
            * Probably OK with units:  phase, polar, rect, sqrt, isfinite,
              isinf, isnan, isclose
        * The general test should be that the function's answer should be
          "obvious".  Thus, for exp(), I wouldn't be able to decide whether
          the value used should be the SI value or the .val attribute,
          meaning exp() cannot take a flt/cpx with units.  However, atan2
          is OK if the two arguments are dimensionally consistent because
          it's their ratio that is used in the function.  Thus, the
          function is allowed with units if you get the same answer using
          either "interpretation" of the number.  For some functions like
          isclose, you need the two arguments to be dimensionally
          consistent and use the same interpretation.
    * Test_sigcomp() fails.
    * flt:  add the engsi feature that will print a prefix with a unit.  If
      it's a multiple unit, surround it in (...).
    * f.py:  see line 150 in test/lwtest_test.py.  
    
        b = cpx(1+1j)
        b.promote = 0
        a = cpx(1+1j, units="m")
        Then in debugger, both a==b and a!=b are False

----------------------------------------------------------------------
Low priority

* fold.py
    * This will change text files to have one space on blank lines or no
      spaces on blank lines.  Need to intelligently process python files?
      The default behavior would be to print each line with 2 lines of
      context on either side.  Then if you like what you see, use -x to
      make the changes.  The intent is to get a source file where { and }
      can be used to navigate to sections you're working on.  Python files
      will be some work because you need to leave multiline strings intact.

* british.py
    * Move to plib and give it a function that will take a sentence of text
      and replace all the British words with English words, maintaining
      capitalization and punctuation.  This will require another function
      to split a string into a list of words and punctuation characters.
      It would be nice to also maintain the spaces between the words too.
      See the next function, which should be in dpstr.py.

* geom_prim.py
    * Update properties to modern syntax, utilize matrix.py for
      determinants, as this would remove dependency on numpy.

* u.py and f.py
    * A notation for using SI prefixes could be to use something like
      μ(N*s/m^2).  This might not be acceptable SI syntax, but it would be
      understandable by anyone and I should use it if the tokenizer in the
      u.py script can be made to utilize it.  A way to do this might be to
      simply insert the equivalent number with a multiplication sign on the
      right when it's encountered; this should evaluate OK with python's
      parser.

* module_dependencies.py
    * Is it necessary?  It needs to be rewritten to accommodate /plib.  The
      tools and programs need to be moved in first.  

* sig.py
    * Is a mess of code.  Is it really all needed?  Maybe it would be best
      to move the key stuff to flt and cpx.  It can still be kept around
      for when it's needed.

* ts.py
    * 'ts.py -m' doesn't work.

* /pylib/pgm/readability/indict.py
    * Looks like an interesting tool.  It should use a reasonable
      dictionary by default and print the tokens out in columns for each
      file.
