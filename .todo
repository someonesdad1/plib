* wrap.py:  Add a Block object that is like wrap, but justifies both the
  right and left margins.
  
  https://medium.com/@dimko1/text-justification-63f4cda29375 gives a
  python solution:

    def fullJustify(words, maxWidth):
        res, curr, num_of_letters = [], [], 0
        for w in words:
            if num_of_letters + len(w) + len(curr) > maxWidth:
                num_of_spaces = maxWidth - num_of_letters
                words_amout = len(curr) - 1 or 1
                for i in range(num_of_spaces):
                    curr[i % words_amout] += ' '
                res.append(''.join(curr))
                curr, num_of_letters = [], 0
            curr += [w]
            num_of_letters += len(w)
        return res + [' '.join(curr).ljust(maxWidth)]

  https://www.malikbrowne.com/blog/text-justification-coding-question

  https://algorithms.tutorialhorizon.com/text-justification-problem/:
  Maintain an index which tracks the numbers of words already used
  (already justified)

    * Say Length = L number of characters in each line.
    * Start taking words into a new line.
    * Keep track of number of characters adding to the new line.
    * Add a special character (‘@’) after each word (later will replace
      by space ‘ ‘)
    * Stop adding word to new line if Either adding new word will exceed
      the characters count in line from given length L Or characters
      count = Length L.
    * Calculate the number of spaces needs to add to make the characters
      count to length L.
    * Evenly distribute the spaces between the selected words. If any
      spaces are left (in case even distribution is not possible), add
      it to between first 2 words.
    * Replace ‘@’ with spaces calculated in the step above.
    * Make a recursive call for rest of the words (from step 2 to Step
      8)

----------------------------------------------------------------------
Low priority

* geom_prim.py:  Update properties to modern syntax, utilize matrix.py
  for determinants, as this would remove dependency on numpy.

* u.py and f.py:  A notation for using SI prefixes could be to use
  something like μ(N*s/m^2).  This might not be acceptable SI syntax,
  but it would be understandable by anyone and I should use it if the
  tokenizer in the u.py script can be made to utilize it.  A way to do
  this might be to simply insert the equivalent number with a
  multiplication sign on the right when it's encountered; this should
  evaluate OK with python's parser.

* module_dependencies.py:   Is it necessary?  It needs to be rewritten
  to accommodate /plib.  The tools and programs need to be moved in
  first.  

* sig is a mess of code.  Is it really all needed?  Maybe it would be
  best to move the key stuff to flt and cpx.  It can still be kept
  around for when it's needed.

* 'ts.py -m' doesn't work.

* /pylib/pgm/readability/indict.py looks like an interesting tool.  
  It should use a reasonable dictionary by default and print the tokens
  out in columns for each file.
